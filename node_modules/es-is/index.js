'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var toString = _interopDefault(require('es-tostring'));
var hasOwn = _interopDefault(require('es-hasown'));

// src/function.coffee
var isFunction;

var isFunction$1 = isFunction = function(value) {
  var str;
  if (typeof window !== 'undefined' && value === window.alert) {
    return true;
  }
  str = toString(value);
  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
};

// src/type.coffee
var isType;

var type = isType = function(value, type) {
  return typeof value === type;
};

// src/defined.coffee
var isDefined;

var defined = isDefined = function(value) {
  return typeof value !== 'undefined';
};

// src/empty.coffee
var isEmpty;

var empty = isEmpty = function(value) {
  var key, type;
  type = toString(value);
  if (type === '[object Array]' || type === '[object Arguments]' || type === '[object String]') {
    return value.length === 0;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (hasOwn(value, key)) {
        return false;
      }
    }
    return true;
  }
  return !value;
};

// src/bool.coffee
var isBool;

var isBool$1 = isBool = function(value) {
  return toString(value) === '[object Boolean]';
};

// src/infinite.coffee
var isInfinite;

var isInfinite$1 = isInfinite = function(value) {
  return value === 2e308 || value === -2e308;
};

// src/number.coffee
var isNumber;

var isNumber$1 = isNumber = function(value) {
  return toString(value) === '[object Number]';
};

// src/array-like.coffee
var isArrayLike;

var isArrayLike$1 = isArrayLike = function(value) {
  return !!value && !isBool$1(value) && hasOwn(value, 'length') && isFinite(value.length) && isNumber$1(value.length) && value.length >= 0;
};

// src/array.coffee
var isArray;

var isArray$1 = isArray = Array.isArray || function(value) {
  return toString(value) === '[object Array]';
};

// src/object.coffee
var isObject;

var isObject$1 = isObject = function(value) {
  return toString(value) === '[object Object]';
};

// src/arguments.coffee
var isArguments;

var isArguments$1 = isArguments = function(value) {
  var isOldArguments, isStandardArguments;
  isStandardArguments = toString(value) === '[object Arguments]';
  isOldArguments = !isArray$1(value) && isArrayLike$1(value) && isObject$1(value) && isFunction$1(value.callee);
  return isStandardArguments || isOldArguments;
};

// src/empty-arguments.coffee
var isEmptyArguments;

var emptyArguments = isEmptyArguments = function(value) {
  return isArguments$1(value) && value.length === 0;
};

// src/empty-array.coffee
var isEmptyArray;

var emptyArray = isEmptyArray = function(value) {
  return isArray$1(value) && value.length === 0;
};

// src/equal.coffee
var isEqual;

var equal = isEqual = function(value, other) {
  var key, type;
  if (value === other) {
    return true;
  }
  type = toString(value);
  if (type !== toString(other)) {
    return false;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (!isEqual(value[key], other[key]) || !(key in other)) {
        return false;
      }
    }
    for (key in other) {
      if (!isEqual(value[key], other[key]) || !(key in value)) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Array]') {
    key = value.length;
    if (key !== other.length) {
      return false;
    }
    while (key--) {
      if (!isEqual(value[key], other[key])) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Function]') {
    return value.prototype === other.prototype;
  }
  if (type === '[object Date]') {
    return value.getTime() === other.getTime();
  }
  return false;
};

// src/hosted.coffee
var NON_HOST_TYPES;
var isHosted;

NON_HOST_TYPES = {
  'boolean': 1,
  number: 1,
  string: 1,
  undefined: 1
};

var hosted = isHosted = function(value, host) {
  var type;
  type = typeof host[value];
  if (type === 'object') {
    return !!host[value];
  } else {
    return !NON_HOST_TYPES[type];
  }
};

// src/instanceof.coffee
var isInstanceOf;

var _instanceof = isInstanceOf = function(value, constructor) {
  return value instanceof constructor;
};

// src/null.coffee
var isNull;

var _null = isNull = function(value) {
  return value === null;
};

// src/undefined.coffee
var isUndefined;

var _undefined = isUndefined = function(value) {
  return typeof value === 'undefined';
};

// src/false.coffee
var isFalse;

var _false = isFalse = function(value) {
  return isBool$1(value) && Boolean(Number(value)) === false;
};

// src/true.coffee
var isTrue;

var _true = isTrue = function(value) {
  return isBool$1(value) && Boolean(Number(value)) === true;
};

// src/date.coffee
var isDate;

var isDate$1 = isDate = function(value) {
  return toString(value) === '[object Date]';
};

// src/valid-date.coffee
var isValidDate;

var validDate = isValidDate = function(value) {
  return isDate$1(value) && !isNaN(Number(value));
};

// src/element.coffee
var isElement;

var element = isElement = function(value) {
  return value !== void 0 && typeof HTMLElement !== 'undefined' && value instanceof HTMLElement && value.nodeType === 1;
};

// src/error.coffee
var isError;

var error = isError = function(value) {
  return toString(value) === '[object Error]';
};

// src/utils.coffee
var isActualNaN = function(value) {
  return value !== value;
};

// src/decimal.coffee
var isDecimal;

var decimal = isDecimal = function(value) {
  return isNumber$1(value) && !isActualNaN(value) && !isInfinite$1(value) && value % 1 !== 0;
};

// src/divisible-by.coffee
var isDivisibleBy;

var divisibleBy = isDivisibleBy = function(value, n) {
  var isDividendInfinite, isDivisorInfinite, isNonZeroNumber;
  isDividendInfinite = isInfinite$1(value);
  isDivisorInfinite = isInfinite$1(n);
  isNonZeroNumber = isNumber$1(value) && !isActualNaN(value) && isNumber$1(n) && !isActualNaN(n) && n !== 0;
  return isDividendInfinite || isDivisorInfinite || isNonZeroNumber && value % n === 0;
};

// src/integer.coffee
var isInteger;

var integer = isInteger = function(value) {
  return isNumber$1(value) && !isActualNaN(value) && value % 1 === 0;
};

// src/max.coffee
var isMax;

var max = isMax = function(value, others) {
  var len;
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isArrayLike$1(others)) {
    throw new TypeError('second argument must be array-like');
  }
  len = others.length;
  while (--len >= 0) {
    if (value < others[len]) {
      return false;
    }
  }
  return true;
};

// src/min.coffee
var isMin;

var min = isMin = function(value, others) {
  var len;
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isArrayLike$1(others)) {
    throw new TypeError('second argument must be array-like');
  }
  len = others.length;
  while (--len >= 0) {
    if (value > others[len]) {
      return false;
    }
  }
  return true;
};

// src/nan.coffee
var isNaN$1;

var nan = isNaN$1 = function(value) {
  return !isNumber$1(value) || value !== value;
};

// src/even.coffee
var isEven;

var even = isEven = function(value) {
  return isInfinite$1(value) || isNumber$1(value) && value === value && value % 2 === 0;
};

// src/odd.coffee
var isOdd;

var odd = isOdd = function(value) {
  return isInfinite$1(value) || isNumber$1(value) && value === value && value % 2 !== 0;
};

// src/ge.coffee
var isGe;

var ge = isGe = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value >= other;
};

// src/gt.coffee
var isGt;

var gt = isGt = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value > other;
};

// src/le.coffee
var isLe;

var le = isLe = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value <= other;
};

// src/lt.coffee
var isLt;

var lt = isLt = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value < other;
};

// src/within.coffee
var isWithin;

var within = isWithin = function(value, start, finish) {
  var isAnyInfinite;
  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isNumber$1(value) || !isNumber$1(start) || !isNumber$1(finish)) {
    throw new TypeError('all arguments must be numbers');
  }
  isAnyInfinite = isInfinite$1(value) || isInfinite$1(start) || isInfinite$1(finish);
  return isAnyInfinite || value >= start && value <= finish;
};

// src/primitive.coffee
var isPrimitive;

var primitive = isPrimitive = function(value) {
  if (!value) {
    return true;
  }
  if (typeof value === 'object' || isObject$1(value) || isFunction$1(value) || isArray$1(value)) {
    return false;
  }
  return true;
};

// src/promise.coffee
var isPromise;

var promise = isPromise = function(value) {
  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
};

// src/hash.coffee
var isHash;

var hash = isHash = function(value) {
  return isObject$1(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
};

// src/regexp.coffee
var isRegExp;

var regexp = isRegExp = function(value) {
  return toString(value) === '[object RegExp]';
};

// src/string.coffee
var isString;

var isString$1 = isString = function(value) {
  return toString(value) === '[object String]';
};

// src/base64.coffee
var base64Regex;
var isBase64;

base64Regex = /^([A-Za-z0-9+\/]{4})*([A-Za-z0-9+\/]{4}|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)$/;

var base64 = isBase64 = function(value) {
  return isString$1(value) && (!value.length || base64Regex.test(value));
};

// src/hex.coffee
var hexRegex;
var isHex;

hexRegex = /^[A-Fa-f0-9]+$/;

var hex = isHex = function(value) {
  return isString$1(value) && (!value.length || hexRegex.test(value));
};

// src/symbol.coffee
var isSymbol;
var symbolValueOf;

symbolValueOf = typeof Symbol === 'function' ? Symbol.prototype.valueOf : void 0;

var symbol = isSymbol = function(value) {
  return typeof Symbol === 'function' && toString(value) === '[object Symbol]' && typeof symbolValueOf.call(value) === 'symbol';
};

// src/index.coffee



var es = Object.freeze({
	isFunction: isFunction$1,
	isType: type,
	isDefined: defined,
	isEmpty: empty,
	isEmptyArguments: emptyArguments,
	isEmptyArray: emptyArray,
	isEqual: equal,
	isHosted: hosted,
	isInstanceOf: _instanceof,
	isNull: _null,
	isUndefined: _undefined,
	isArguments: isArguments$1,
	isArray: isArray$1,
	isArrayLike: isArrayLike$1,
	isBool: isBool$1,
	isFalse: _false,
	isTrue: _true,
	isDate: isDate$1,
	isValidDate: validDate,
	isElement: element,
	isError: error,
	isNumber: isNumber$1,
	isInfinite: isInfinite$1,
	isDecimal: decimal,
	isDivisibleBy: divisibleBy,
	isInteger: integer,
	isMax: max,
	isMin: min,
	isNaN: nan,
	isEven: even,
	isOdd: odd,
	isGe: ge,
	isGt: gt,
	isLe: le,
	isLt: lt,
	isWithin: within,
	isObject: isObject$1,
	isPrimitive: primitive,
	isPromise: promise,
	isHash: hash,
	isRegExp: regexp,
	isString: isString$1,
	isBase64: base64,
	isHex: hex,
	isSymbol: symbol
});

// src/cjs.coffee
var exports$1;
var k;
var v;

exports$1 = {
  type: type,
  defined: defined,
  empty: empty,
  equal: equal,
  hosted: hosted,
  'instanceof': _instanceof,
  instance: _instanceof,
  nil: _null,
  "null": _null,
  undefined: _undefined,
  undef: _undefined,
  'arguments': isArguments$1,
  args: isArguments$1,
  array: isArray$1,
  arraylike: isArrayLike$1,
  bool: isBool$1,
  "false": _false,
  "true": _true,
  date: isDate$1,
  element: element,
  error: error,
  "function": isFunction$1,
  fn: isFunction$1,
  number: isNumber$1,
  infinite: isInfinite$1,
  decimal: decimal,
  divisibleBy: divisibleBy,
  integer: integer,
  maximum: max,
  max: max,
  minimum: min,
  min: min,
  nan: nan,
  even: even,
  odd: odd,
  ge: ge,
  gt: gt,
  le: le,
  lt: lt,
  within: within,
  object: isObject$1,
  primitive: primitive,
  promise: promise,
  hash: hash,
  regexp: regexp,
  string: isString$1,
  base64: base64,
  hex: hex,
  symbol: symbol
};

exports$1.args.empty = emptyArguments;

exports$1["arguments"].empty = emptyArguments;

exports$1.array.empty = emptyArray;

exports$1.date.valid = validDate;

for (k in es) {
  v = es[k];
  exports$1[k] = v;
}

var exports$2 = exports$1;

module.exports = exports$2;
//# sourceMappingURL=index.js.map
